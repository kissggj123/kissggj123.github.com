<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ğŸ¨ æ²™ç”»å·¥ä½œå®¤ V31 (ä¸‡è±¡ç‰ˆ)</title>
    
    <!-- æ ¸å¿ƒåº“ -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.4.2/pixi.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@simonwep/pickr/dist/pickr.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/stats.js/r16/Stats.min.js"></script>
    
    <!-- æ ·å¼ -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@simonwep/pickr/dist/themes/nano.min.css"/>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=ZCOOL+KuaiLe&family=Noto+Sans+SC:wght@400;700&display=swap" rel="stylesheet">

    <style>
        :root {
            /* é»˜è®¤ä¸»é¢˜ï¼šæš—å¤œ */
            --bg: #121212;
            --panel: rgba(28, 28, 28, 0.95);
            --accent: #00e5ff;
            --border: #333;
            --text: #eee;
            --text-dim: #888;
        }

        body { margin: 0; overflow: hidden; background: var(--bg); font-family: 'Noto Sans SC', sans-serif; color: var(--text); user-select: none; transition: background 0.3s; }
        #stage { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 0; cursor: crosshair; }
        
        /* UI é¢æ¿ */
        .panel {
            position: fixed; background: var(--panel); border: 1px solid var(--border);
            border-radius: 8px; backdrop-filter: blur(12px); z-index: 100;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5); display: flex; flex-direction: column;
            transition: all 0.3s ease;
        }
        
        .header {
            padding: 10px 15px; background: rgba(255,255,255,0.05); border-bottom: 1px solid var(--border);
            display: flex; justify-content: space-between; align-items: center; cursor: move;
            font-size: 13px; font-weight: 700; color: var(--accent); letter-spacing: 1px;
        }

        .content { padding: 15px; overflow-y: auto; max-height: 80vh; scrollbar-width: thin; }
        
        /* å·¦ä¾§å·¥å…·æ  */
        #tools { top: 20px; left: 20px; width: 46px; align-items: center; padding-bottom: 10px; }
        .tool-btn {
            width: 36px; height: 36px; margin-bottom: 6px; border-radius: 6px;
            background: transparent; border: 1px solid transparent; color: var(--text-dim);
            cursor: pointer; display: flex; justify-content: center; align-items: center; transition: 0.2s;
            position: relative; font-size: 14px;
        }
        .tool-btn:hover { color: var(--text); background: rgba(255,255,255,0.1); }
        .tool-btn.active { color: #000; background: var(--accent); box-shadow: 0 0 10px var(--accent); font-weight: bold; }
        
        /* Tooltip */
        .tool-btn::after { 
            content: attr(data-tip); position: absolute; left: 115%; top: 50%; transform: translateY(-50%); 
            background: var(--panel); border: 1px solid var(--border); color: var(--text); padding: 4px 8px; 
            font-size: 11px; border-radius: 4px; pointer-events: none; opacity: 0; transition: 0.2s; 
            white-space: nowrap; z-index: 200; 
        }
        .tool-btn:hover::after { opacity: 1; left: 125%; }

        /* å³ä¾§è®¾ç½® */
        #settings { top: 20px; right: 20px; width: 290px; }
        .section { margin-bottom: 15px; border-bottom: 1px solid var(--border); padding-bottom: 12px; }
        .section:last-child { border-bottom: none; }
        .section-title { font-size: 11px; color: var(--text-dim); text-transform: uppercase; margin-bottom: 10px; font-weight: 700; letter-spacing: 0.5px; }
        
        .row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; gap: 8px; }
        label { font-size: 12px; color: var(--text-dim); white-space: nowrap; }
        
        /* è‡ªå®šä¹‰æ§ä»¶ */
        input[type="range"] { flex: 1; height: 4px; background: var(--border); border-radius: 2px; appearance: none; }
        input[type="range"]::-webkit-slider-thumb { appearance: none; width: 14px; height: 14px; background: var(--accent); border-radius: 50%; cursor: pointer; border: 2px solid var(--panel); }
        
        select, input[type="text"], input[type="number"] {
            background: rgba(0,0,0,0.2); border: 1px solid var(--border); color: var(--text);
            padding: 4px 6px; border-radius: 4px; font-size: 12px; outline: none;
        }
        .val { font-size: 10px; width: 28px; text-align: right; color: var(--text-dim); font-family: monospace; }

        /* ç½‘æ ¼æŒ‰é’® */
        .grid-btns { display: grid; grid-template-columns: repeat(4, 1fr); gap: 5px; margin-top:5px; }
        .grid-btn { height: 32px; background: rgba(255,255,255,0.05); border: 1px solid var(--border); border-radius: 4px; color: var(--text-dim); cursor: pointer; transition: 0.2s; font-size: 12px; }
        .grid-btn:hover { color: var(--text); border-color: var(--accent); }
        .grid-btn.active { background: var(--accent); color: #000; border-color: var(--accent); }

        /* å›¾å±‚åˆ—è¡¨ */
        #layer-list { list-style: none; padding: 0; margin: 0; max-height: 150px; overflow-y: auto; background: rgba(0,0,0,0.2); border: 1px solid var(--border); border-radius: 4px; }
        .layer-li { padding: 8px 10px; display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid var(--border); cursor: pointer; font-size: 12px; transition: 0.2s; }
        .layer-li:hover { background: rgba(255,255,255,0.05); }
        .layer-li.active { background: rgba(255,255,255,0.1); border-left: 3px solid var(--accent); }
        
        /* æ¨¡æ€æ¡† */
        .modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 2000; display: none; justify-content: center; align-items: center; backdrop-filter: blur(5px); }
        .modal-box { background: var(--panel); width: 320px; padding: 20px; border-radius: 8px; border: 1px solid var(--border); box-shadow: 0 20px 50px rgba(0,0,0,0.5); }
        
        .btn { width: 100%; padding: 8px; margin-top: 10px; background: var(--accent); color: #000; border: none; border-radius: 4px; cursor: pointer; font-weight: bold; transition: 0.2s; }
        .btn:hover { filter: brightness(1.1); }
        .btn-sec { background: rgba(255,255,255,0.1); color: var(--text); }
        .btn-danger { background: #ff4757; color: white; }

        /* Pickr */
        .pickr .pcr-button { width: 100% !important; height: 32px !important; border-radius: 4px; border: 1px solid var(--border); }
    </style>
</head>
<body>

    <div id="stage"></div>
    
    <!-- æ–‡æœ¬æ¨¡æ€æ¡† -->
    <div id="text-modal" class="modal">
        <div class="modal-box">
            <h3 style="margin-top:0; color:var(--accent); border-bottom:1px solid var(--border); padding-bottom:10px;">æ·»åŠ æ–‡å­—</h3>
            <input type="text" id="tm-input" placeholder="åœ¨æ­¤è¾“å…¥æ–‡å­—..." style="width:94%; padding:8px; background:rgba(0,0,0,0.3); border:1px solid var(--border); color:var(--text); margin-bottom:15px; border-radius:4px;">
            <div class="row"><label>å­—å·</label><input type="number" id="tm-size" value="80" style="width:60px"></div>
            <div class="row"><label>å­—ä½“</label><select id="tm-font" style="width:120px"><option value="ZCOOL KuaiLe">å¿«ä¹ä½“</option><option value="Noto Sans SC">æ€æºé»‘ä½“</option><option value="serif">å®‹ä½“</option><option value="cursive">æ‰‹å†™ä½“</option></select></div>
            <div style="display:flex; gap:10px; margin-top:20px;">
                <button class="btn btn-sec" onclick="UI.closeModals()">å–æ¶ˆ</button>
                <button class="btn" id="tm-confirm">ç”Ÿæˆæ–‡å­—</button>
            </div>
        </div>
    </div>

    <!-- å·¦ä¾§å·¥å…·æ  -->
    <div class="panel" id="tools">
        <button class="tool-btn active" data-tool="brush" data-tip="ç”»ç¬” (B)"><i class="fas fa-paint-brush"></i></button>
        <button class="tool-btn" data-tool="eraser" data-tip="æ©¡çš® (E)"><i class="fas fa-eraser"></i></button>
        <button class="tool-btn" data-tool="line" data-tip="ç›´çº¿ (L)"><i class="fas fa-slash"></i></button>
        <button class="tool-btn" data-tool="text" data-tip="æ–‡å­— (T)"><i class="fas fa-font"></i></button>
        <button class="tool-btn" data-tool="stencil" data-tip="æ¨¡å…· (M)"><i class="fas fa-shapes"></i></button>
        <button class="tool-btn" data-tool="eyedropper" data-tip="å¸ç®¡ (Alt)"><i class="fas fa-eye-dropper"></i></button>
        <button class="tool-btn" data-tool="move" data-tip="ç§»åŠ¨ç”»å¸ƒ (Space)"><i class="fas fa-arrows-alt"></i></button>
        <div style="width:20px; height:1px; background:var(--border); margin:5px 0"></div>
        <button class="tool-btn" id="act-undo" data-tip="æ’¤é”€ (Ctrl+Z)"><i class="fas fa-undo"></i></button>
        <button class="tool-btn" id="act-clear" data-tip="æ¸…ç©ºå½“å‰å±‚"><i class="fas fa-trash"></i></button>
    </div>

    <!-- å³ä¾§è®¾ç½®é¢æ¿ -->
    <div class="panel" id="settings">
        <div class="header" id="drag-h">
            <span><i class="fas fa-palette"></i> æ²™ç”»å·¥ä½œå®¤ V31</span>
            <i class="fas fa-bars" style="opacity:0.5"></i>
        </div>
        <div class="content">
            
            <!-- é¢œè‰²ä¸ä¸»é¢˜ -->
            <div class="section">
                <div class="section-title">è‰²å½© & ä¸»é¢˜</div>
                <div id="pickr-container"></div>
                <div class="row" style="margin-top:10px">
                    <label>ç•Œé¢ä¸»é¢˜</label>
                    <select id="theme-select" style="flex:1; margin-left:10px;">
                        <option value="dark">ğŸŒ‘ æš—å¤œ (é»˜è®¤)</option>
                        <option value="light">â˜€ï¸ æ˜äº® (ç™½æ˜¼)</option>
                        <option value="cyber">ğŸ¤– èµ›åš (éœ“è™¹)</option>
                        <option value="retro">ğŸ“œ å¤å¤ (çº¸å¼ )</option>
                    </select>
                </div>
                <button class="grid-btn" style="width:100%; margin-top:5px;" id="btn-light-table"><i class="fas fa-lightbulb"></i> åˆ‡æ¢æ²™ç›˜èƒŒå…‰æ¨¡å¼</button>
            </div>

            <!-- ç¬”åˆ·å¼•æ“ -->
            <div class="section">
                <div class="section-title">ç¬”åˆ·å¼•æ“</div>
                <div class="row">
                    <label>ç¬”åˆ·ç±»å‹</label>
                    <select id="brush-type" style="flex:1; margin-left:10px;">
                        <option value="sand">ğŸœï¸ ç»†æ²™ (æ ‡å‡†)</option>
                        <option value="gravel">ğŸª¨ ç²—ç ¾ (ç²—ç³™)</option>
                        <option value="neon">âœ¨ éœ“è™¹ (å‘å…‰)</option>
                        <option value="fire">ğŸ”¥ ç«ç„° (åŠ¨æ€)</option>
                        <option value="ice">â„ï¸ å†°é›ª (é£˜è½)</option>
                        <option value="rainbow">ğŸŒˆ å½©è™¹ (å˜è‰²)</option>
                        <option value="charcoal">âœï¸ æœ¨ç‚­ (çº¹ç†)</option>
                    </select>
                </div>
                <div class="row"><label>å°ºå¯¸</label><input type="range" id="p-size" min="2" max="150" value="25"><span class="val" id="v-size">25</span></div>
                <div class="row"><label>æµé‡</label><input type="range" id="p-flow" min="1" max="50" value="10"><span class="val" id="v-flow">10</span></div>
                <div class="row"><label>é«˜åº¦</label><input type="range" id="p-height" min="0" max="200" value="50" title="æ§åˆ¶ä¸‹è½æ‰©æ•£"><span class="val" id="v-height">50</span></div>
                <div class="row"><label>æŠ–åŠ¨</label><input type="range" id="p-stab" min="0" max="20" value="5" title="çº¿æ¡å¹³æ»‘ä¿®æ­£"><span class="val" id="v-stab">5</span></div>
                
                <!-- é«˜çº§å‚æ•° -->
                <div style="margin-top:5px; border-top:1px dashed var(--border); padding-top:5px;">
                    <div class="row"><label>æ‚è‰²</label><input type="range" id="p-jitter" min="0" max="100" value="10"><span class="val" id="v-jitter">10</span></div>
                    <div class="row"><label>é‡åŠ›</label><input type="range" id="p-gravity" min="1" max="20" value="8"><span class="val" id="v-gravity">0.8</span></div>
                </div>

                <div class="row" style="margin-top:5px;">
                    <label>ç‰©ç†æ¨¡å¼</label>
                    <select id="p-mode" style="flex:1; margin-left:10px;">
                        <option value="physics">ğŸŒŠ è½æ²™åŠ¨ç”»</option>
                        <option value="instant">âš¡ é™æ€é€Ÿç»˜</option>
                    </select>
                </div>
            </div>

            <!-- æ¨¡å…·ç³»ç»Ÿ -->
            <div class="section" id="stencil-sec" style="display:none">
                <div class="section-title">æ¨¡å…·é®ç½©</div>
                <div class="grid-btns">
                    <button class="grid-btn" onclick="Stencil.set('circle')"><i class="far fa-circle"></i></button>
                    <button class="grid-btn" onclick="Stencil.set('square')"><i class="far fa-square"></i></button>
                    <button class="grid-btn" onclick="Stencil.set('star')"><i class="far fa-star"></i></button>
                    <button class="grid-btn" onclick="Stencil.set('heart')"><i class="far fa-heart"></i></button>
                </div>
                <div class="row" style="margin-top:8px"><label>ç¼©æ”¾</label><input type="range" id="s-scale" min="20" max="200" value="100"></div>
                <div class="row"><label>æ—‹è½¬</label><input type="range" id="s-rot" min="0" max="360" value="0"></div>
                <button class="btn btn-danger" style="margin-top:5px; padding:5px;" onclick="Stencil.clear()">å…³é—­æ¨¡å…·</button>
            </div>

            <!-- å›¾å±‚ç®¡ç† -->
            <div class="section">
                <div class="section-title" style="display:flex; justify-content:space-between;">
                    å›¾å±‚ç®¡ç† <i class="fas fa-plus" style="cursor:pointer; color:var(--accent)" id="act-add-layer" title="æ–°å»ºå›¾å±‚"></i>
                </div>
                <ul id="layer-list"></ul>
                <div style="display:flex; gap:5px; margin-top:10px;">
                    <button class="grid-btn" style="flex:1" id="act-save"><i class="fas fa-download"></i> ä¿å­˜å›¾ç‰‡</button>
                    <button class="grid-btn" style="flex:1" id="act-img"><i class="fas fa-image"></i> æ’å…¥å›¾ç‰‡</button>
                </div>
                <input type="file" id="file-input" style="display:none" accept="image/*">
            </div>
        </div>
    </div>

    <script>
        // ==========================================
        // 1. æ ¸å¿ƒé…ç½®ä¸ä¸»é¢˜
        // ==========================================
        const Config = { 
            width: 3000, height: 2000, 
            maxParticles: 40000, // æå‡ç²’å­ä¸Šé™
        };

        const Themes = {
            dark: { bg: '#121212', panel: 'rgba(28,28,28,0.95)', accent: '#00e5ff', text: '#eee', border: '#333', canvas: 0x121212 },
            light: { bg: '#e0e0e0', panel: 'rgba(255,255,255,0.95)', accent: '#ff9800', text: '#333', border: '#ccc', canvas: 0xe0e0e0 },
            cyber: { bg: '#050510', panel: 'rgba(10,10,30,0.9)', accent: '#ff00ff', text: '#00ffff', border: '#00aaaa', canvas: 0x050510 },
            retro: { bg: '#3e2723', panel: 'rgba(62,39,35,0.95)', accent: '#d7ccc8', text: '#ffccbc', border: '#5d4037', canvas: 0x3e2723 }
        };

        const State = {
            tool: 'brush',
            color: '#00e5ff', colorInt: 0x00e5ff,
            brushType: 'sand',
            brush: { size: 25, flow: 10, height: 50, stab: 5, mode: 'physics', jitter: 10, gravity: 0.8 },
            stencil: { active: false, type: null, scale: 1, rot: 0 },
            layers: [], activeLayer: null,
            isDrawing: false, isLightTable: false,
            currentTheme: 'dark'
        };

        // ==========================================
        // 2. Pixi å¼•æ“åˆå§‹åŒ–
        // ==========================================
        const app = new PIXI.Application({
            resizeTo: window, backgroundColor: Themes.dark.canvas,
            antialias: false, resolution: window.devicePixelRatio || 1,
            preserveDrawingBuffer: true, autoDensity: true
        });
        document.getElementById('stage').appendChild(app.view);

        const viewport = new PIXI.Container();
        app.stage.addChild(viewport);
        viewport.position.set(window.innerWidth/2, window.innerHeight/2);

        // ç”»å¸ƒèƒŒæ™¯
        const bgSprite = new PIXI.Sprite(PIXI.Texture.WHITE);
        bgSprite.width = Config.width; bgSprite.height = Config.height;
        bgSprite.anchor.set(0.5);
        bgSprite.tint = Themes.dark.canvas;
        bgSprite.filters = [new PIXI.filters.NoiseFilter(0.1)]; // ç£¨ç ‚è´¨æ„Ÿ
        viewport.addChild(bgSprite);

        // å®¹å™¨å±‚çº§ï¼šå›¾å±‚ -> é¢„è§ˆ -> ç²’å­
        const layerContainer = new PIXI.Container();
        layerContainer.position.set(-Config.width/2, -Config.height/2);
        viewport.addChild(layerContainer);

        const previewLayer = new PIXI.Container();
        viewport.addChild(previewLayer);

        const particleContainer = new PIXI.ParticleContainer(Config.maxParticles, {
            position:true, scale:true, alpha:true, tint:true
        });
        particleContainer.position.set(-Config.width/2, -Config.height/2);
        viewport.addChild(particleContainer);

        // ç²’å­çº¹ç†
        const pixelTex = app.renderer.generateTexture(new PIXI.Graphics().beginFill(0xffffff).drawCircle(0,0,2).endFill());

        // ==========================================
        // 3. ç¬”åˆ·ä¸ç‰©ç†é€»è¾‘ (æ ¸å¿ƒ)
        // ==========================================
        
        // HSL å·¥å…·
        function hexToHsl(hex) {
            let r = (hex >> 16) & 255, g = (hex >> 8) & 255, b = hex & 255;
            r /= 255; g /= 255; b /= 255;
            let max = Math.max(r, g, b), min = Math.min(r, g, b);
            let h, s, l = (max + min) / 2;
            if (max == min) h = s = 0;
            else {
                let d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                switch (max) { case r: h = (g - b) / d + (g < b ? 6 : 0); break; case g: h = (b - r) / d + 2; break; case b: h = (r - g) / d + 4; break; }
                h /= 6;
            }
            return { h, s, l };
        }
        function hslToHex(h, s, l) {
            let r, g, b;
            if (s == 0) r = g = b = l;
            else {
                const hue2rgb = (p, q, t) => {
                    if (t < 0) t += 1; if (t > 1) t -= 1;
                    if (t < 1/6) return p + (q - p) * 6 * t;
                    if (t < 1/2) return q;
                    if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                    return p;
                };
                const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                const p = 2 * l - q;
                r = hue2rgb(p, q, h + 1/3); g = hue2rgb(p, q, h); b = hue2rgb(p, q, h - 1/3);
            }
            return ((r * 255) << 16) + ((g * 255) << 8) + (b * 255);
        }

        // ç‰©ç†å¼•æ“
        const Physics = {
            active: [], pool: [],
            spawn(x, y) {
                const p = this.pool.pop() || new PIXI.Sprite(pixelTex);
                p.anchor.set(0.5);
                
                // ç¬”åˆ·ç‰¹æœ‰å±æ€§
                const type = State.brushType;
                const height = State.brush.height;
                const spread = height * (type==='ice'?0.4:0.2); // å†°é›ªæ‰©æ•£å¤§
                
                p.tx = x; p.ty = y;
                p.x = x + (Math.random()-0.5)*spread;
                p.y = y + (Math.random()-0.5)*spread;
                p.z = height + Math.random() * 20;
                p.vz = 0;
                p.life = 0; // ç”¨äºå½©è™¹/ç«ç„°

                // é¢œè‰²å¤„ç† (æ‚è‰²/å½©è™¹)
                if (type === 'rainbow') {
                    p.tint = hslToHex((Date.now()%1000)/1000, 1, 0.5);
                } else if (State.brush.jitter > 0) {
                    const hsl = hexToHsl(State.colorInt);
                    const jit = State.brush.jitter/200;
                    // ç«ç„°å˜çº¢/é»„
                    if (type==='fire') { hsl.h = 0.05 + (Math.random()-0.5)*0.1; hsl.s=1; hsl.l=0.5 + Math.random()*0.3; }
                    else { hsl.l = Math.max(0, Math.min(1, hsl.l + (Math.random()-0.5)*jit)); }
                    p.tint = hslToHex(hsl.h, hsl.s, hsl.l);
                } else {
                    p.tint = State.colorInt;
                }

                // æ··åˆæ¨¡å¼
                if (type==='neon' || type==='fire' || type==='ice') p.blendMode = PIXI.BLEND_MODES.ADD;
                else if (type==='charcoal') p.blendMode = PIXI.BLEND_MODES.MULTIPLY;
                else p.blendMode = PIXI.BLEND_MODES.NORMAL;

                // ç‰©ç†å·®å¼‚
                let grav = State.brush.gravity;
                if (type==='fire') grav *= 0.3; // ç«ç„°é£˜è½æ…¢
                if (type==='ice') grav *= 0.5; // å†°é›ªé£˜
                if (type==='gravel') grav *= 1.5; // çŸ³å­é‡

                const t = Math.sqrt(2*p.z/grav);
                p.vx = (p.tx - p.x)/t;
                p.vy = (p.ty - p.y)/t;
                p.grav = grav;

                p.alpha = 0.6;
                p.scale.set(1 + p.z*0.02);
                if (type==='gravel') p.scale.set(p.scale.x * 1.5);

                particleContainer.addChild(p);
                this.active.push(p);
            },
            update() {
                for(let i=this.active.length-1; i>=0; i--) {
                    const p = this.active[i];
                    p.vz += p.grav; p.z -= p.vz;
                    p.x += p.vx; p.y += p.vy;
                    p.life++;

                    // è§†è§‰æ›´æ–°
                    p.scale.set(Math.max(0.5, 1 + p.z*0.01));
                    if (State.brushType === 'fire') {
                        p.alpha = Math.random()*0.8; // é—ªçƒ
                    } else {
                        p.alpha = Math.min(1, 1.2 - p.z*0.005);
                    }

                    if (p.z <= 0) {
                        Baker.add(p.tx, p.ty, p.tint, p.scale.x, p.blendMode);
                        this.kill(i);
                    }
                }
            },
            kill(i) {
                const p = this.active[i];
                this.active.splice(i,1);
                particleContainer.removeChild(p);
                this.pool.push(p);
            }
        };

        // çƒ˜ç„™å™¨
        const Baker = {
            q: [], eq: [],
            add(x, y, c, s, blend) {
                if (State.stencil.active && !Stencil.contains(x, y)) return;
                
                if (State.tool === 'eraser') {
                    this.eq.push({x, y, s});
                } else {
                    this.q.push({x, y, c, s, b: blend});
                }
            },
            flush() {
                const l = State.activeLayer;
                if (!l) { this.q=[]; this.eq=[]; return; }
                
                // æ“¦é™¤
                if (this.eq.length) {
                    const g = new PIXI.Graphics();
                    this.eq.forEach(p => {
                        g.beginFill(0xffffff); g.drawCircle(p.x, p.y, State.brush.size*0.6); g.endFill();
                    });
                    app.renderer.render(g, {renderTexture: l.tex, clear: false, blendMode: PIXI.BLEND_MODES.ERASE});
                    this.eq = [];
                }
                
                // ç»˜åˆ¶ (åˆ†æ‰¹æ¬¡ï¼ŒåŒæ··åˆæ¨¡å¼æœ€å¥½ä¸€æ‰¹ï¼Œè¿™é‡Œç®€åŒ–ä¸ºç›´æ¥Container)
                if (this.q.length) {
                    const c = new PIXI.Container();
                    const limit = Math.min(this.q.length, 2000);
                    for(let i=0; i<limit; i++){
                        const d = this.q[i];
                        const s = new PIXI.Sprite(pixelTex);
                        s.position.set(d.x, d.y); s.tint = d.c; s.scale.set(d.s * 0.7); s.anchor.set(0.5);
                        s.blendMode = d.b;
                        c.addChild(s);
                    }
                    this.q.splice(0, limit);
                    app.renderer.render(c, {renderTexture: l.tex, clear: false});
                    c.destroy({children:true});
                }
            }
        };

        // ==========================================
        // 4. æ¨¡å…·ä¸å·¥å…·
        // ==========================================
        const Stencil = {
            guide: new PIXI.Graphics(),
            init() { previewLayer.addChild(this.guide); this.guide.visible = false; },
            set(type) {
                State.stencil.active = true; State.stencil.type = type;
                State.tool = 'brush'; UI.updateTools();
                document.getElementById('stencil-sec').style.display = 'block';
                this.draw();
            },
            clear() {
                State.stencil.active = false; this.guide.visible = false;
                document.getElementById('stencil-sec').style.display = 'none';
            },
            draw() {
                const g = this.guide; g.clear(); g.lineStyle(2, 0xffffff, 0.5); g.beginFill(0x000000, 0.3);
                const s = 200 * (State.stencil.scale/100);
                g.rotation = State.stencil.rot * Math.PI / 180;
                if(State.stencil.type === 'circle') g.drawCircle(0,0,s);
                else if(State.stencil.type === 'square') g.drawRect(-s,-s,s*2,s*2);
                else if(State.stencil.type === 'star') this.drawStar(g,0,0,5,s,s/2);
                else if(State.stencil.type === 'heart') this.drawHeart(g,0,0,s);
                g.endFill(); g.visible = true;
            },
            drawStar(g,x,y,p,o,i) { g.moveTo(0,-o); for(let j=0; j<2*p; j++) { const r = (j%2===0)?o:i; const a = (Math.PI/p)*j - Math.PI/2; g.lineTo(x+Math.cos(a)*r, y+Math.sin(a)*r); } g.closePath(); },
            drawHeart(g,x,y,s) { g.moveTo(x, y-s/2); g.bezierCurveTo(x+s/2, y-s, x+s, y, x, y+s); g.bezierCurveTo(x-s, y, x-s/2, y-s, x, y-s/2); },
            contains(x, y) {
                const global = layerContainer.toGlobal({x,y});
                const local = this.guide.toLocal(global);
                return this.guide.containsPoint(global) || this.guide.geometry.containsPoint(local);
            }
        };

        const Tools = {
            lineStart: null, linePreview: new PIXI.Graphics(),
            init() { previewLayer.addChild(this.linePreview); },
            onDown(x, y) { if (State.tool === 'line') this.lineStart = {x, y}; },
            onMove(x, y) {
                if (State.tool === 'line' && this.lineStart) {
                    const p1 = previewLayer.toLocal(layerContainer.toGlobal(this.lineStart));
                    const p2 = previewLayer.toLocal(layerContainer.toGlobal({x,y}));
                    this.linePreview.clear().lineStyle(2, State.colorInt).moveTo(p1.x, p1.y).lineTo(p2.x, p2.y);
                }
            },
            onUp(x, y) {
                if (State.tool === 'line' && this.lineStart) {
                    this.linePreview.clear();
                    const d = Math.hypot(x-this.lineStart.x, y-this.lineStart.y);
                    const s = Math.ceil(d/2);
                    for(let i=0; i<s; i++) {
                        const t = i/s;
                        processStroke(this.lineStart.x + (x-this.lineStart.x)*t, this.lineStart.y + (y-this.lineStart.y)*t, i===0);
                    }
                    this.lineStart = null;
                }
            },
            createText(txt, size, font) {
                const t = new PIXI.Text(txt, { fontFamily: font, fontSize: parseInt(size), fill: State.colorInt });
                t.anchor.set(0.5); t.position.set(Config.width/2, Config.height/2);
                if(State.activeLayer) app.renderer.render(t, {renderTexture:State.activeLayer.tex, clear:false});
            }
        };

        // ==========================================
        // 5. è¾“å…¥å¤„ç† & ç¬”åˆ·é€»è¾‘
        // ==========================================
        function getLocalPos(e) {
            // æ ¸å¿ƒä¿®æ­£ï¼šå±å¹•åæ ‡ -> å›¾å±‚æœ¬åœ°åæ ‡
            return layerContainer.toLocal({x: e.clientX, y: e.clientY});
        }

        let pts = [], lastPos = null;
        function processStroke(x, y, start) {
            if (start) { pts = []; lastPos = {x, y}; }
            pts.push({x, y});
            if (pts.length > State.brush.stab) pts.shift();
            
            let ax=0, ay=0;
            pts.forEach(p => {ax+=p.x; ay+=p.y});
            ax/=pts.length; ay/=pts.length;
            
            if (start) { lastPos = {x:ax, y:ay}; return; }
            
            const dist = Math.hypot(ax-lastPos.x, ay-lastPos.y);
            const step = Math.max(1, State.brush.size/3);
            const steps = Math.ceil(dist / step);
            
            for(let i=0; i<steps; i++) {
                const t = i/steps;
                const ix = lastPos.x + (ax-lastPos.x)*t;
                const iy = lastPos.y + (ay-lastPos.y)*t;
                
                if (State.tool === 'eraser') {
                    Baker.add(ix, iy, 0, 1); continue;
                }
                
                const count = State.brush.flow;
                const r = State.brush.size/2;
                
                for(let j=0; j<count; j++) {
                    const ang = Math.random()*Math.PI*2;
                    const rad = Math.sqrt(Math.random())*r;
                    const px = ix + Math.cos(ang)*rad;
                    const py = iy + Math.sin(ang)*rad;
                    
                    if(State.brush.mode==='physics') Physics.spawn(px, py);
                    else {
                        let tint = State.colorInt;
                        let blend = PIXI.BLEND_MODES.NORMAL;
                        if (State.brushType === 'fire' || State.brushType === 'neon') blend = PIXI.BLEND_MODES.ADD;
                        if (State.brushType === 'rainbow') tint = hslToHex(Math.random(), 1, 0.5);
                        Baker.add(px, py, tint, 1, blend);
                    }
                }
            }
            lastPos = {x:ax, y:ay};
        }

        // äº‹ä»¶ç›‘å¬
        let isDrag = false, dragOff = {x:0, y:0};
        
        window.addEventListener('pointerdown', e => {
            if (e.target !== app.view) return;
            if (e.button===1 || State.tool==='move' || e.ctrlKey) {
                isDrag=true; dragOff={x:e.clientX-viewport.x, y:e.clientY-viewport.y};
                document.body.style.cursor='grabbing';
            } else if (State.tool==='eyedropper') {
                const p = app.renderer.extract.pixels(viewport, new PIXI.Rectangle(e.clientX, e.clientY, 1, 1));
                const hex = "#" + ((1<<24)+(p[0]<<16)+(p[1]<<8)+p[2]).toString(16).slice(1);
                pickr.setColor(hex); State.tool='brush'; UI.updateTools();
            } else if (State.tool==='line') {
                const p = getLocalPos(e); Tools.onDown(p.x, p.y);
            } else {
                State.isDrawing = true;
                const p = getLocalPos(e);
                processStroke(p.x, p.y, true);
            }
        });

        window.addEventListener('pointermove', e => {
            if (isDrag) {
                viewport.x = e.clientX - dragOff.x; viewport.y = e.clientY - dragOff.y;
            } else if (State.tool === 'line') {
                const p = getLocalPos(e); Tools.onMove(p.x, p.y);
            } else if (State.isDrawing) {
                const p = getLocalPos(e); processStroke(p.x, p.y, false);
            }
        });

        window.addEventListener('pointerup', e => {
            isDrag = false; document.body.style.cursor='default';
            const p = getLocalPos(e);
            if (State.tool === 'line') Tools.onUp(p.x, p.y);
            State.isDrawing = false;
        });

        window.addEventListener('wheel', e => {
            if(e.target===app.view) { e.preventDefault(); const s = viewport.scale.x*(e.deltaY>0?0.9:1.1); viewport.scale.set(Math.max(0.1, Math.min(5, s))); }
        }, {passive:false});

        // ==========================================
        // 6. UI & çŠ¶æ€ç®¡ç†
        // ==========================================
        const LayerManager = {
            add(name) {
                const tex = PIXI.RenderTexture.create({width:Config.width, height:Config.height});
                const spr = new PIXI.Sprite(tex);
                const l = { id:Date.now(), name, tex, spr, vis:true };
                State.layers.push(l);
                layerContainer.addChild(spr);
                this.setActive(l);
            },
            setActive(l) { State.activeLayer = l; UI.renderLayers(); },
            clearActive() {
                if(State.activeLayer) app.renderer.render(new PIXI.Graphics().beginFill(0,0).drawRect(0,0,Config.width,Config.height), {renderTexture:State.activeLayer.tex, clear:true});
            }
        };

        const pickr = Pickr.create({
            el: '#pickr-container', theme: 'nano', default: State.color,
            components: { preview: true, opacity: true, hue: true, interaction: { input: true, save: true } }
        });
        pickr.on('save', (c, i) => { State.color = c.toHEXA().toString(); State.colorInt = parseInt(State.color.replace('#','0x')); i.hide(); });

        const UI = {
            init() {
                Stencil.init(); Tools.init(); LayerManager.add('èƒŒæ™¯å±‚');
                
                // Tools
                document.querySelectorAll('.tool-btn').forEach(b => {
                    b.onclick = () => {
                        if(b.dataset.tool==='text') document.getElementById('text-modal').style.display='flex';
                        else { State.tool = b.dataset.tool; this.updateTools(); if(State.tool!=='stencil') Stencil.clear(); }
                    };
                });

                // Bindings
                const bind = (id, k, vid) => { document.getElementById(id).oninput = e => { State.brush[k]=parseFloat(e.target.value); if(vid)document.getElementById(vid).innerText=e.target.value; if(id.includes('s-')) Stencil.draw(); }};
                bind('p-size','size','v-size'); bind('p-flow','flow','v-flow'); bind('p-height','height','v-height'); bind('p-stab','stab','v-stab'); bind('p-jitter','jitter','v-jitter'); bind('p-gravity','gravity','v-gravity');
                bind('s-scale','scale'); bind('s-rot','rot');
                
                document.getElementById('p-mode').onchange = e => State.brush.mode = e.target.value;
                document.getElementById('brush-type').onchange = e => State.brushType = e.target.value;

                // Actions
                document.getElementById('act-add-layer').onclick = () => LayerManager.add(`å›¾å±‚ ${State.layers.length+1}`);
                document.getElementById('act-clear').onclick = () => LayerManager.clearActive();
                document.getElementById('act-save').onclick = () => app.renderer.extract.canvas(viewport).toBlob(b=>{const a=document.createElement('a');a.download='sandart.png';a.href=URL.createObjectURL(b);a.click()});
                document.getElementById('btn-light-table').onclick = () => {
                    State.isLightTable = !State.isLightTable;
                    bgSprite.tint = State.isLightTable ? 0xeeeeee : Themes[State.currentTheme].canvas;
                    State.colorInt = State.isLightTable ? 0x111111 : 0x00e5ff;
                    pickr.setColor(State.isLightTable ? '#111111' : '#00e5ff');
                };
                
                // Themes
                document.getElementById('theme-select').onchange = (e) => {
                    State.currentTheme = e.target.value;
                    const t = Themes[State.currentTheme];
                    const r = document.documentElement.style;
                    r.setProperty('--bg', t.bg); r.setProperty('--panel', t.panel);
                    r.setProperty('--accent', t.accent); r.setProperty('--text', t.text); r.setProperty('--border', t.border);
                    if(!State.isLightTable) bgSprite.tint = t.canvas;
                };

                // Text
                document.getElementById('tm-confirm').onclick = () => {
                    const v = document.getElementById('tm-input').value;
                    if(v) Tools.createText(v, document.getElementById('tm-size').value, document.getElementById('tm-font').value);
                    this.closeModals();
                };
                
                // Image Import
                document.getElementById('act-img').onclick = () => document.getElementById('file-input').click();
                document.getElementById('file-input').onchange = e => {
                    const f = e.target.files[0]; if(!f) return;
                    const reader = new FileReader();
                    reader.onload = evt => {
                        const img = new Image();
                        img.onload = () => {
                            const base = new PIXI.BaseTexture(img);
                            const spr = new PIXI.Sprite(new PIXI.Texture(base));
                            const scale = Math.min(Config.width/spr.width, Config.height/spr.height) * 0.8;
                            spr.scale.set(scale); spr.anchor.set(0.5); spr.position.set(Config.width/2, Config.height/2);
                            LayerManager.add("å›¾ç‰‡");
                            app.renderer.render(spr, {renderTexture:State.activeLayer.tex});
                        };
                        img.src = evt.target.result;
                    };
                    reader.readAsDataURL(f);
                };

                // Drag Panel
                const h=document.getElementById('drag-h'), p=document.getElementById('settings');
                let d=false, o={x:0,y:0};
                h.onmousedown=e=>{d=true; o={x:e.clientX-p.offsetLeft,y:e.clientY-p.offsetTop}};
                window.onmousemove=e=>{if(d){p.style.left=(e.clientX-o.x)+'px'; p.style.top=(e.clientY-o.y)+'px'}};
                window.onmouseup=()=>d=false;
            },
            
            updateTools() { document.querySelectorAll('.tool-btn').forEach(b => b.classList.toggle('active', b.dataset.tool===State.tool)); },
            renderLayers() {
                const ul = document.getElementById('layer-list'); ul.innerHTML='';
                [...State.layers].reverse().forEach(l => {
                    const li = document.createElement('li'); li.className=`layer-li ${l===State.activeLayer?'active':''}`;
                    li.innerHTML=`<span>${l.name}</span><i class="fas fa-eye" style="opacity:${l.vis?1:0.5}"></i>`;
                    li.onclick=()=>LayerManager.setActive(l);
                    li.querySelector('i').onclick=(e)=>{e.stopPropagation();l.vis=!l.vis;l.spr.visible=l.vis;UI.renderLayers()};
                    ul.appendChild(li);
                });
            },
            closeModals() { document.querySelectorAll('.modal').forEach(m => m.style.display='none'); }
        };

        // å¯åŠ¨
        UI.init();
        app.ticker.add(() => { Physics.update(); Baker.flush(); });

    </script>
</body>
</html>